import React, { useState, useEffect } from 'react';
import { BookOpen, Star, CheckCircle, XCircle, ArrowRight, Award, RefreshCw, HelpCircle, Upload, Edit3, Globe, ExternalLink, LayoutGrid, RotateCcw, Home, LogOut } from 'lucide-react';

// --- DATA: DEFAULT USER LIST ---
const DEFAULT_USER_LIST = [
  { word: "ÂìÑÂ†ÇÂ§ßÁ¨ë", meaning: "A burst of laughter" },
  { word: "Âπæ‰πé", meaning: "Almost" },
  { word: "ÊÜ§ÊÄí", meaning: "Angry" },
  { word: "ÊèêÂïè", meaning: "Question" },
  { word: "ÂèçÊáâ", meaning: "Reaction" },
  { word: "ÈáçË§á", meaning: "Repeated" },
  { word: "ÁæûÊÑß", meaning: "Shame" },
  { word: "ÁõØ", meaning: "Stare" },
  { word: "Âè£Ëø∞", meaning: "Oral narration" },
  { word: "ÂåÜÂøô", meaning: "Hurriedly" },
  { word: "‰∏ÄÂÄãÂãÅÂÖí", meaning: "Without stopping" },
  { word: "ÁãºÁãΩ", meaning: "Embarrassed" },
  { word: "ÂõõÈù¢ÂÖ´Êñπ", meaning: "From all directions" },
  { word: "ÈÄ£Âøô", meaning: "Quickly" },
  { word: "Á®±ËÆö", meaning: "Praise" },
  { word: "Ë°®Êèö", meaning: "Commendation" },
  { word: "ÊªëÊ∫úÊ∫ú", meaning: "Slippery" },
  { word: "ÊÉ¶Ë®ò", meaning: "Thinking about" },
  { word: "ÈÇÄË´ã", meaning: "Inviting" },
  { word: "Á•ùÁ¶è", meaning: "Blessing" },
  { word: "‰ΩîÁî®", meaning: "Occupy" },
  { word: "ÂÆâÊÖ∞", meaning: "Comfort" },
  { word: "ÂøôÁ¢å", meaning: "Busy" },
  { word: "ÁçéÂãµ", meaning: "Reward" },
  { word: "ÈÖ£Áù°", meaning: "Sound sleep" },
  { word: "Ë≤¨‰ªª", meaning: "Responsibility" },
  { word: "ÈÄêÊº∏", meaning: "Gradually" },
  { word: "Ëø´‰∏çÂèäÂæÖ", meaning: "Impatiently" },
  { word: "Áí∞Â¢É", meaning: "Environment" },
  { word: "ÊµÅÂà©", meaning: "Fluently" },
  { word: "ÊîπÂñÑ", meaning: "Improve" },
  { word: "ÂõûÂë≥", meaning: "Savoring" },
  { word: "ÈÅ©Êáâ", meaning: "Adapting" },
  { word: "Ê∫ñÁ¢∫", meaning: "Accurately" },
  { word: "ÊõºÂ¶ô", meaning: "Graceful" },
  { word: "ÁîòÁîú", meaning: "Sweet" },
  { word: "ÊÇÑÊÇÑ", meaning: "Quietly" },
  { word: "È¶ôÊ∞£ÂõõÊ∫¢", meaning: "Fragrant" },
  { word: "ÈáÄ", meaning: "Brew" },
  { word: "Âê±Âê±Âñ≥Âñ≥", meaning: "Squeaking" },
  { word: "ÊêñÊõ≥", meaning: "Swaying" },
  { word: "ËáâÈæê", meaning: "Face" },
  { word: "ÁëüÁëüÁôºÊäñ", meaning: "Shivering" },
  { word: "ÂüãÊÄ®", meaning: "Complaining" },
  { word: "ÂóìÂ≠ê", meaning: "Voice" },
  { word: "ÊÇ∂ÁÜ±", meaning: "Hot" },
  { word: "Ê∏ÖÊ∂º", meaning: "Cool" },
  { word: "ÊúüÂæÖ", meaning: "Expecting" },
  { word: "Âêå‰º¥", meaning: "Companion" },
  { word: "ËÆöÁæé", meaning: "Praise" }
];

// --- GAME ASSETS & DATABASES ---

// 1. DICTIONARY (Fallback / Expansion)
const VOCAB_DICTIONARY = {
  "Â†ÖÊØÖ": "Perseverance", "Â∞äÈáç": "Respect", "Ë≤¨‰ªªÊÑü": "Responsibility", 
  "Â≠∏Ê†°": "School", "ËÄÅÂ∏´": "Teacher", "Â≠∏Áîü": "Student", "ÊúãÂèã": "Friend"
};

// 2. SIMILAR CHARACTERS MAP (For Game 2: Differentiation)
const SIMILAR_CHAR_MAP = {
  // From user list
 "ÂìÑ": ["È¨®", "ÂìÖ", "ÂìÑ"], // ÂìÑÂ†ÇÂ§ßÁ¨ë
  "Âπæ": ["Ê©ü", "ËÇå", "Á£Ø"], // Âπæ‰πé
  "‰πé": ["Âëº", "ÂøΩ", "Á≥ä"], // Âπæ‰πé
  "ÊÜ§": ["Âøø", "Â•Æ", "ÁÄµ"], // ÊÜ§ÊÄí
  "Êèê": ["È°å", "Â†§", "Âïº"], // ÊèêÂïè
  "Âïè": ["ËÅû", "ÊÇ∂", "Èñ©"], // ÊèêÂïè
  "Âèç": ["Ëøî", "Èò™", "Âèõ"], // ÂèçÊáâ
  "Êáâ": ["Êò†", "Á°¨", "Áë©"], // ÂèçÊáâ
  "Èáç": ["Á®Æ", "Á´•", "Âãï"], // ÈáçË§á
  "Ë§á": ["Ë¶Ü", "ËÖπ", "Âæ©"], // ÈáçË§á
  "Áæû": ["‰øè", "ÊÅ•", "ËÑ©"], // ÁæûÊÑß
  "ÁõØ": ["Ë®Ç", "Áî∫", "Áõº"], // ÁõØ
  "ÂåÜ": ["Âø°", "Âåà", "ÂÖÖ"], // ÂåÜÂøô
  "Áãº": ["ÁêÖ", "ÈÉé", "Âªä"], // ÁãºÁãΩ
  "Âõõ": ["ËÇÜ", "Ê≥ó", "ÁΩí"], // ÂõõÈù¢ÂÖ´Êñπ
  "ÈÄ£": ["ËÅØ", "Âªâ", "Êº£"], // ÈÄ£Âøô
  "Á®±": ["Áß§", "Ë•Ø", "ÂÅÅ"], // Á®±ËÆö
  "Ë°®": ["Ë£±", "‰øµ", "Â©ä"], // Ë°®Êèö
  "Êªë": ["Áåæ", "Ê¥ª", "È™®"], // ÊªëÊ∫úÊ∫ú
  "ÊÉ¶": ["Âøµ", "ÊéÇ", "‰ΩÉ"], // ÊÉ¶Ë®ò
  "ÈÇÄ": ["ÈÅô", "Êêñ", "Ëïò"], // ÈÇÄË´ã
  "Á•ù": ["Á•ö", "Ë®ª", "ÁØâ"], // Á•ùÁ¶è
  "‰Ωî": ["Âç†", "Ê≤æ", "ÁÇπ"], // ‰ΩîÁî®
  "ÂÆâ": ["Êåâ", "Ê°à", "Â≤∏"], // ÂÆâÊÖ∞
  "Âøô": ["Ëäí", "Áõ≤", "Ëå´"], // ÂøôÁ¢å
  "Áçé": ["Â•¨", "Â∞á", "ÈÜ¨"], // ÁçéÂãµ
  "ÈÖ£": ["Âê´", "ÂáΩ", "Ê±ó"], // ÈÖ£Áù°
  "Ë≤¨": ["Ë≥æ", "Á∏æ", "Ë≤¨"], // Ë≤¨‰ªª
  "ÈÄê": ["ÂïÑ", "ÈÄó", "ÈÄê"], // ÈÄêÊº∏
  "Ëø´": ["ÈÄº", "ÁèÄ", "Ê≥ä"], // Ëø´‰∏çÂèäÂæÖ
  "Áí∞": ["ÈÇÑ", "Âúú", "Èç∞"], // Áí∞Â¢É
  "ÊµÅ": ["Áïô", "Ê¶¥", "Á°´"], // ÊµÅÂà©
  "Êîπ": ["Êî∫", "Â¶É", "‰∏ê"], // ÊîπÂñÑ
  "Âõû": ["Ëø¥", "Ê¥Ñ", "ÊÇî"], // ÂõûÂë≥
  "ÈÅ©": ["Ë¨ö", "Êª¥", "Êïµ"], // ÈÅ©Êáâ
  "Ê∫ñ": ["ÂáÜ", "Ê∑Æ", "Ê∫ñ"], // Ê∫ñÁ¢∫
  "Êõº": ["ÊÖ¢", "Êº´", "ÁÜ≥"], // ÊõºÂ¶ô
  "Áîò": ["Êüë", "Ëã∑", "Ê≥î"], // ÁîòÁîú
  "ÊÇÑ": ["‰øè", "Â≥≠", "ÈõÄ"], // ÊÇÑÊÇÑ
  "È¶ô": ["ÈÑâ", "Áøî", "Áõ∏"], // È¶ôÊ∞£ÂõõÊ∫¢
  "ÈáÄ": ["ÈÜ∏", "ÈáÅ", "ËÆì"], // ÈáÄ
  "Âê±": ["Êªã", "Âí®", "Âßø"], // Âê±Âê±Âñ≥Âñ≥
  "Êêñ": ["ÈÅô", "Áë§", "Ë¨†"], // ÊêñÊõ≥
  "Ëáâ": ["ÂÑâ", "Êæ∞", "Âªâ"], // ËáâÈæê
  "Áëü": ["Â°û", "Ê£Æ", "Ê∂©"], // ÁëüÁëüÁôºÊäñ
  "Âüã": ["Ë≤∑", "ÈÇÅ", "ËÑà"], // ÂüãÊÄ®
  "ÊÄ®": ["Èô¢", "ÂÆõ", "Áà∞"], // ÂüãÊÄ®
  "Âóì": ["Âó©", "Âóá", "Ê°ë"], // ÂóìÂ≠ê
  "ÊÇ∂": ["Âïè", "ÊÇµ", "ÊÇ∏"], // ÊÇ∂ÁÜ±
  "Ê∏Ö": ["Êô¥", "ÊÉÖ", "Ëúª"], // Ê∏ÖÊ∂º
  "Êúü": ["Ê¨∫", "Ê£ã", "Áïø"], // ÊúüÂæÖ
  "ÂæÖ": ["Ë¢ã", "ÊÄ†", "ÈÄÆ"], // ÊúüÂæÖ
  "Âêå": ["Á´•", "ÂΩ§", "Ê°ê"], // Âêå‰º¥
  "‰º¥": ["ËÉñ", "Êãå", "Áïî"], // Âêå‰º¥
  "ËÆö": ["Ë¥ä", "Áìö", "ÈÖá"] // ËÆöÁæé
  "ÊÑß": ["Âå±", "ÊΩ∞", "È¨º"], // ÁæûÊÑß
  "Âøô": ["Ëäí", "Áõ≤", "Ëå´"], // ÂåÜÂøô
  "ÁãΩ": ["Ë≤ù", "ËÉå", "ÊÇñ"], // ÁãºÁãΩ
  "Èù¢": ["È∫µ", "Èù£", "ÂÅ≠"], // ÂõõÈù¢ÂÖ´Êñπ
  "Êñπ": ["Âùä", "Ëä≥", "Èò≤"], // ÂõõÈù¢ÂÖ´Êñπ
  "Âøô": ["Ëäí", "Áõ≤", "Ëå´"], // ÈÄ£Âøô
  "ËÆö": ["Ë¥ä", "Áìö", "ÈÖá"], // Á®±ËÆö
  "Êèö": ["ÈôΩ", "Ê•ä", "Êöò"], // Ë°®Êèö
  "Ê∫ú": ["Áïô", "Ê¶¥", "ÊµÅ"], // ÊªëÊ∫úÊ∫ú
  "Ë®ò": ["Á¥Ä", "Â∑±", "Ë®ò"], // ÊÉ¶Ë®ò
  "Á¶è": ["Á•ø", "ÂπÖ", "Ëù†"], // Á•ùÁ¶è
  "Ë´ã": ["Ê∏Ö", "ÊÉÖ", "Ëúª"], // ÈÇÄË´ã
  "ÊÖ∞": ["Â∞â", "Ë¨Ç", "Áïè"], // ÂÆâÊÖ∞
  "Á¢å": ["ÈåÑ", "Á•ø", "Èô∏"], // ÂøôÁ¢å
  "Âãµ": ["Âé≤", "Ëê¨", "‰æã"], // ÁçéÂãµ
  "Êº∏": ["Ê∏õ", "Êñ¨", "Ëî™"], // ÈÄêÊº∏
  "ÂæÖ": ["Ë¢ã", "‰æç", "ÈÄÆ"] // Ëø´‰∏çÂèäÂæÖ


  
  // Existing
  "Ëæ®": ["ËæØ", "Ëæ¶", "Áì£"], "ËæØ": ["Ëæ®", "Ëæ¶", "Áì£"],
  "Ë±™": ["ÊØ´", "Ëíô", "Ë±°"], "ÊØ´": ["Ë±™", "ÊØõ", "Êâã"],
  "Ê∏Ö": ["Èùí", "Ë´ã", "ÊÉÖ", "Êô¥", "Áùõ"], "Èùí": ["Ê∏Ö", "Ë´ã", "ÊÉÖ"],
  "Êô¥": ["Áùõ", "Ê∏Ö", "Èùí"], "Áùõ": ["Êô¥", "Ê∏Ö", "Èùí"],
  "Ë≤∑": ["Ë≥£", "ÂØ¶", "È†≠"], "Ë≥£": ["Ë≤∑", "ËÆÄ", "ÂØ¶"],
  "ÂÖ•": ["‰∫∫", "ÂÖ´"], "‰∫∫": ["ÂÖ•", "ÂÖ´", "Â§ß"],
  "Âçà": ["Áâõ", "ÂçÉ", "Âπ≤"], "Áâõ": ["Âçà", "Áîü", "Êâã"],
  "Â∑≤": ["Â∑±", "Â∑≥"], "Â∑±": ["Â∑≤", "Â∑≥"]
};

// 3. RELATIONS DB (For Game 3: Synonyms/Antonyms)
const RELATIONS_DB = {
  // From user list
"ÂìÑÂ†ÇÂ§ßÁ¨ë": { type: "synonym", target: "Â§ßÁ¨ë", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê≤âÈªò", "Âì≠Ê≥£", "ÂòÜÊ∞£"] },
"Âπæ‰πé": { type: "synonym", target: "Â∑ÆÈªû", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["‰∏ÄÂÆö", "ÂÆåÂÖ®", "ÂøÖÁÑ∂"] },
"ÊÜ§ÊÄí": { type: "synonym", target: "ÁîüÊ∞£", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÈñãÂøÉ", "ÊÑüÂãï", "Âπ≥Èùú"] },
"ÊèêÂïè": { type: "synonym", target: "ÁôºÂïè", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂõûÁ≠î", "Ê≤âÈªò", "ÊãíÁµï"] },
"ÂèçÊáâ": { type: "synonym", target: "ÂõûÊáâ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂøΩÁï•", "ÊãíÁµï", "ÈùúÊ≠¢"] },
"ÈáçË§á": { type: "synonym", target: "ÂÜç‰∏â", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂÅúÊ≠¢", "ÁúÅÁï•", "Ë∑≥ÈÅé"] },
"ÁæûÊÑß": { type: "synonym", target: "ÊÖöÊÑß", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂæóÊÑè", "È©ïÂÇ≤", "ÊîæÈ¨Ü"] },
"ÁõØ": { type: "synonym", target: "ÂáùË¶ñ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂøΩË¶ñ", "ÈñâÁúº", "ËΩâÈ†≠"] },
"Âè£Ëø∞": { type: "synonym", target: "Èô≥Ëø∞", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Èñ±ËÆÄ", "Ê≤âÈªò", "ÂØ´‰Ωú"] },
"ÂåÜÂøô": { type: "synonym", target: "ÊÄ•Âøô", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂæûÂÆπ", "Á∑©ÊÖ¢", "ÊÇ†Èñí"] },
"‰∏ÄÂÄãÂãÅÂÖí": { type: "synonym", target: "‰∏çÂÅú", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂÅ∂Áàæ", "ÂãâÂº∑", "ÊúâÊôÇ"] },
"ÁãºÁãΩ": { type: "synonym", target: "Á™òËø´", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ëá™Âú®", "ËºïÈ¨Ü", "Á©©Èáç"] },
"ÂõõÈù¢ÂÖ´Êñπ": { type: "synonym", target: "ÂêÑËôï", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊüêËôï", "‰∏ÄÂÅ¥", "ÈôÑËøë"] },
"ÈÄ£Âøô": { type: "synonym", target: "Ë∂ïÁ∑ä", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊÖ¢ÊÖ¢", "ÈÅ≤Áñë", "ÂÅú‰∏ã"] },
"Á®±ËÆö": { type: "synonym", target: "ËÆöÊèö", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊâπË©ï", "ÊîªÊìä", "Ë≤¨ÁΩµ"] },
"Ë°®Êèö": { type: "synonym", target: "ÂòâË®±", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊåáË≤¨", "‰æÆËæ±", "Âê¶ÂÆö"] },
"ÊªëÊ∫úÊ∫ú": { type: "synonym", target: "ÂÖâÊªë", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Á≤óÁ≥ô", "‰πæÁá•", "ÈªèÁ≥ä"] },
"ÊÉ¶Ë®ò": { type: "synonym", target: "ÊéõÂøµ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂøòË®ò", "ÁÑ°Ë¶ñ", "ÂøΩÁï•"] },
"ÈÇÄË´ã": { type: "synonym", target: "Á¥ÑË´ã", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊãíÁµï", "ÂøΩË¶ñ", "ÂëΩ‰ª§"] },
"Á•ùÁ¶è": { type: "synonym", target: "Á•ùÈ°ò", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ë©õÂíí", "ÊâπË©ï", "Âò≤Á¨ë"] },
"‰ΩîÁî®": { type: "synonym", target: "‰ΩøÁî®", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê≠∏ÈÇÑ", "ÊîæÊ£Ñ", "Á©∫ÁΩÆ"] },
"ÂÆâÊÖ∞": { type: "synonym", target: "Êí´ÊÖ∞", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ë≤¨ÊÄ™", "Âà∫ÊøÄ", "Ë≠èË´∑"] },
"ÂøôÁ¢å": { type: "synonym", target: "ÁπÅÂøô", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê∏ÖÈñí", "Á©∫Èñí", "‰ºëÊÅØ"] },
"ÁçéÂãµ": { type: "synonym", target: "ÂòâÁçé", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Êá≤ÁΩ∞", "Ë≤¨ÂÇô", "ÂøΩÁï•"] },
"ÈÖ£Áù°": { type: "synonym", target: "ÁÜüÁù°", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê∏ÖÈÜí", "È©öÈÜí", "Â∞èÁù°"] },
"Ë≤¨‰ªª": { type: "synonym", target: "Áæ©Âãô", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê¨äÂà©", "Ëá™Áî±", "ÁâπÊ¨ä"] },
"ÈÄêÊº∏": { type: "synonym", target: "ÊÖ¢ÊÖ¢", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Á´ãÂç≥", "Á™ÅÁÑ∂", "È¶¨‰∏ä"] },
"Ëø´‰∏çÂèäÂæÖ": { type: "synonym", target: "ÊÄ•Âàá", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂÜ∑Èùú", "Ê∑°ÁÑ∂", "‰∏çÂú®ÊÑè"] },
"Áí∞Â¢É": { type: "synonym", target: "Âë®ÈÅ≠", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Áâ©ÂìÅ", "‰∫∫Áâ©", "‰∫ã‰ª∂"] },
"ÊµÅÂà©": { type: "synonym", target: "È†ÜÊö¢", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÁµêÂ∑¥", "ÂÅúÈ†ì", "Âç°‰Ωè"] },
"ÊîπÂñÑ": { type: "synonym", target: "ÊèêÂçá", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊÉ°Âåñ", "‰∏ãÈôç", "ÈÄÄÊ≠•"] },
"ÂõûÂë≥": { type: "synonym", target: "ÂõûÊÉ≥", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂøòÂçª", "ÂøΩÁï•", "ÊãíÁµï"] },
"ÈÅ©Êáâ": { type: "synonym", target: "ÁøíÊÖ£", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊéíÊñ•", "ÊäµÊäó", "ÂèçÂ∞ç"] },
"Ê∫ñÁ¢∫": { type: "synonym", target: "Á≤æÁ¢∫", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Âê´Á≥ä", "ÈåØË™§", "Â§ßÊ¶Ç"] },
"ÊõºÂ¶ô": { type: "synonym", target: "ÂÑ™Áæé", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Á≤óÈ≠Ø", "ÂÉµÁ°¨", "Á¨®Êãô"] },
"ÁîòÁîú": { type: "synonym", target: "ÁîúÁæé", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ëã¶ÊæÄ", "ÈÖ∏Ëæ£", "ÁÑ°Âë≥"] },
"ÊÇÑÊÇÑ": { type: "synonym", target: "ÈùúÈùú", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Â§ßËÅ≤", "ÂñßÈ¨ß", "ÂêµÂö∑"] },
"È¶ôÊ∞£ÂõõÊ∫¢": { type: "synonym", target: "Ëä≥È¶ôÊí≤Èºª", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ëá≠Ê∞£Ê≤ñÂ§©", "Âπ≥Ê∑°ÁÑ°Âë≥", "ÁÑ°È¶ô"] },
"ÈáÄ": { type: "synonym", target: "Ë£Ω‰Ωú", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Á†¥Â£û", "ÂÄíÊéâ", "ÂÅúÊ≠¢"] },
"Âê±Âê±Âñ≥Âñ≥": { type: "synonym", target: "Âò∞Âò∞Âñ≥Âñ≥", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê≤âÈªò", "ÂÆâÈùú", "ÁÑ°ËÅ≤"] },
"ÊêñÊõ≥": { type: "synonym", target: "Êì∫Âãï", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Âõ∫ÂÆö", "ÈùúÊ≠¢", "ÂÉµÁ°¨"] },
"ËáâÈæê": { type: "synonym", target: "Èù¢ÂÆπ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊâãÊéå", "ËÉåÈÉ®", "ËÇ©ËÜÄ"] },
"ÁëüÁëüÁôºÊäñ": { type: "synonym", target: "È°´Êäñ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Á´ôÁ©©", "ÈùúÊ≠¢", "ÈéÆÂÆö"] },
"ÂüãÊÄ®": { type: "synonym", target: "Êä±ÊÄ®", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ËÆöÁæé", "ÊÑüË¨ù", "Ê¨£Ë≥û"] },
"ÂóìÂ≠ê": { type: "synonym", target: "ÂñâÂö®", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÁúºÁùõ", "ÈºªÂ≠ê", "ËÄ≥Êúµ"] },
"ÊÇ∂ÁÜ±": { type: "synonym", target: "ÊΩÆÁÜ±", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Ê∏ÖÊ∂º", "ÂØíÂÜ∑", "‰πæÁá•"] },
"Ê∏ÖÊ∂º": { type: "synonym", target: "Ê∂ºÁàΩ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÁÇéÁÜ±", "ÊÇ∂ÁÜ±", "Áá•ÁÜ±"] },
"ÊúüÂæÖ": { type: "synonym", target: "ÁõºÊúõ", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Â§±Êúõ", "ÂøΩÁï•", "ÊîæÊ£Ñ"] },
"Âêå‰º¥": { type: "synonym", target: "Â§•‰º¥", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["Êïµ‰∫∫", "ÈôåÁîü‰∫∫", "Â∞çÊâã"] },
"ËÆöÁæé": { type: "synonym", target: "Á®±ËÆö", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊâπË©ï", "ÁæûËæ±", "Âê¶ÂÆö"] }

  // Existing
  "Âø´Ê®Ç": { type: "synonym", target: "È´òËàà", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÊÇ≤ÂÇ∑", "ÊÜ§ÊÄí", "ÊìîÂøÉ"] },
  "ÊÇ≤ÂÇ∑": { type: "antonym", target: "Âø´Ê®Ç", mode: "ÂèçÁæ©Ë©û (Antonym)", distractors: ["Èõ£ÈÅé", "ÁóõËã¶", "ÊÜÇÊÑÅ"] },
  "ÊàêÂäü": { type: "antonym", target: "Â§±Êïó", mode: "ÂèçÁæ©Ë©û (Antonym)", distractors: ["ÂãùÂà©", "ÂÆåÊàê", "ÈÅîÂà∞"] },
  "Â§±Êïó": { type: "antonym", target: "ÊàêÂäü", mode: "ÂèçÁæ©Ë©û (Antonym)", distractors: ["Ëº∏Êéâ", "ÈåØË™§", "Êå´Êäò"] },
  "Á∞°ÂñÆ": { type: "antonym", target: "Âõ∞Èõ£", mode: "ÂèçÁæ©Ë©û (Antonym)", distractors: ["ÂÆπÊòì", "Ê∏ÖÊô∞", "ÂñÆÁ¥î"] },
  "Âõ∞Èõ£": { type: "synonym", target: "Ëâ±Èõ£", mode: "ËøëÁæ©Ë©û (Synonym)", distractors: ["ÂÆπÊòì", "ËºïÈ¨Ü", "Á∞°ÂñÆ"] }
};

// 4. SENTENCE DB (For Game 4: Fill in the Blanks)
const SENTENCE_DB = {
  // From user list
  "ÂìÑÂ†ÇÂ§ßÁ¨ë": "ËÅΩÂà∞ÈÄôÂÄãÁ¨ëË©±ÔºåÂÖ®Áè≠ÂêåÂ≠∏ÈÉΩ____„ÄÇ",
  "Âπæ‰πé": "ÈÄôË£°ÁöÑÈ¢®ÊôØÁæéÂæó____ËÆì‰∫∫ÂøòË®òÂëºÂê∏„ÄÇ",
  "ÊÜ§ÊÄí": "‰ªñÂ∞çÈÄôÂÄãÁÑ°ÁêÜÁöÑË¶ÅÊ±ÇÊÑüÂà∞ÈùûÂ∏∏____„ÄÇ",
  "ÊèêÂïè": "ËÄÅÂ∏´ÈºìÂãµÊàëÂÄëÂ§ö____Ôºå‰∏çË¶Å‰∏çÊáÇË£ùÊáÇ„ÄÇ",
  "ÁæûÊÑß": "Âõ†ÁÇ∫Ë™™Ë¨äÔºå‰ªñÊÑüÂà∞ÂçÅÂàÜ____„ÄÇ",
  "ÁõØ": "Ë≠¶ÂØüÊ≠ªÊ≠ªÂú∞____ËëóÈÇ£ÂÄãÂèØÁñëÁöÑÂ∞èÂÅ∑„ÄÇ",
  "ÂåÜÂøô": "‰ªñ____Âú∞ÂêÉÂÆåÊó©È§êÂ∞±Âéª‰∏äÂ≠∏‰∫Ü„ÄÇ",
  "ÁãºÁãΩ": "Á™ÅÂ¶ÇÂÖ∂‰æÜÁöÑÂ§ßÈõ®ËÆì‰ªñÊ∑ãÂæóÂçÅÂàÜ____„ÄÇ",
  "Á®±ËÆö": "ËÄÅÂ∏´____‰ªñÂ≠óÂØ´ÂæóÂæàÊºÇ‰∫Æ„ÄÇ",
  "ÈÇÄË´ã": "Êàë____ÊúãÂèã‰æÜÂèÉÂä†ÊàëÁöÑÁîüÊó•Ê¥æÂ∞ç„ÄÇ",
  "ÂÆâÊÖ∞": "ÊúãÂèãÂÇ∑ÂøÉÊôÇÔºåÊàëÂÄëË¶ÅÂéª____‰ªñ„ÄÇ",
  "ÂøôÁ¢å": "Áà∏Áà∏ÊØèÂ§©Â∑•‰ΩúÈÉΩÂæà____ÔºåÂæàÂ∞ëÂú®ÂÆ∂„ÄÇ",
  "Ë≤¨‰ªª": "‰øùË≠∑Áí∞Â¢ÉÊòØÊØèÂÄã‰∫∫ÁöÑ____„ÄÇ",
  "ÊµÅÂà©": "‰ªñËÉΩË™™‰∏ÄÂè£____ÁöÑÊôÆÈÄöË©±„ÄÇ",
  "ÊîπÂñÑ": "ÊàëÂÄëË¶ÅÂä™Âäõ____Â≠∏ÁøíÊñπÊ≥ïÔºåÊèêÈ´òÊïàÁéá„ÄÇ",
  "ÂõûÂë≥": "ÈÄôÈÅìËèúÁöÑÂë≥ÈÅìËÆì‰∫∫____ÁÑ°Á™Æ„ÄÇ",
  "ÈÅ©Êáâ": "‰ªñÂæàÂø´Â∞±____‰∫ÜÊñ∞Â≠∏Ê†°ÁöÑÁîüÊ¥ª„ÄÇ",
  "Ê∫ñÁ¢∫": "Ë´ã‰Ω†____Âú∞ÂõûÁ≠îÊàëÁöÑÂïèÈ°å„ÄÇ",
  "ÊúüÂæÖ": "ÊàëÂçÅÂàÜ____ÊöëÂÅáÁöÑ‰æÜËá®„ÄÇ",
  "ÊªëÊ∫úÊ∫ú": "ÈÄôÊ¢ùÈ≠ö____ÁöÑÔºåÂæàÈõ£Êäì„ÄÇ",
  "Áí∞Â¢É": "ÊàëÂÄëË¶ÅÊÑõË≠∑____Ôºå‰∏çË¶Å‰∫Ç‰∏üÂûÉÂúæ„ÄÇ",
  "ÁçéÂãµ": "Â¶ÇÊûú‰Ω†ËÄÉÂæóÂ•ΩÔºåÂ™ΩÂ™ΩÊúÉ____‰Ω†‰∏Ä‰ªΩÁ¶ÆÁâ©„ÄÇ",
  "ÂìÑÂ†ÇÂ§ßÁ¨ë": "Ê†°Èï∑Âú®Âè∞‰∏äË¨õ‰∫Ü‰∏ÄÂè•Á¨ëË©±ÔºåÂÖ®Â†¥ÂêåÂ≠∏ÈÉΩ____„ÄÇ",
  "Âπæ‰πé": "‰ªäÂ§©Â§™ÂåÜÂøô‰∫ÜÔºåÊàë____Âøò‰∫ÜÂ∏∂ÂäüË™≤„ÄÇ",
  "ÊÜ§ÊÄí": "Âì•Âì•ÊääÊàëÁöÑÊ®°ÂûãÂºÑÂ£û‰∫ÜÔºåÊàëÊÑüÂà∞ÂçÅÂàÜ____„ÄÇ",
  "ÊèêÂïè": "ËÄÅÂ∏´ÈºìÂãµÊàëÂÄëÂú®Ë™≤Â†Ç‰∏äÂãáÊñº____„ÄÇ",
  "ÂèçÊáâ": "ËÄÅÂ∏´Ëµ∞Âà∞Êï£ÊÖ¢ÁöÑÂêåÂ≠∏Êû±ÂâçÔºåÂöáÂæó‰ªñÁ´ãÂàª____ÈÅé‰æÜ„ÄÇ",
  "ÈáçË§á": "ÈÄôÊÆµÂè•Â≠êË¶Å____ÊúóËÆÄ‰∏âÈÅçÔºåÊâçËÉΩÊõ¥ÁÜüÁøí„ÄÇ",
  "ÁæûÊÑß": "ÂøòË®òÁ≠îË¨ùÂà•‰∫∫ÁöÑÂπ´ÂøôÔºåÊàëÊÑüÂà∞ÊúâÈªû____„ÄÇ",
  "ÁõØ": "Â∞èË≤ì‰∏ÄÁõ¥____ÁùÄÁ™óÂ§ñÁöÑÈ≥•ÂÖí„ÄÇ",
  "Âè£Ëø∞": "Â§™ÂÖ¨____‰ªñÂÖíÊôÇÁöÑÁ∂ìÊ≠∑ÔºåÊàëËÅΩÂæóÊ¥•Ê¥•ÊúâÂë≥„ÄÇ",
  "ÂåÜÂøô": "‰ªñÂ§™____‰∫ÜÔºåÁµêÊûúÊääÊ∞¥Â£∫ÂøòÂú®Ê°å‰∏ä„ÄÇ",
  "‰∏ÄÂÄãÂãÅÂÖí": "Â¶πÂ¶π____Âú∞Âì≠ÔºåÊÄéÊ®£ÂÆâÊÖ∞‰πüÂÅú‰∏ç‰∏ã‰æÜ„ÄÇ",
  "ÁãºÁãΩ": "‰∏ãÂ§ßÈõ®ÊôÇÊàëÊ≤íÊúâÂ∏∂Èõ®ÂÇòÔºåÂÖ®Ë∫´Ë¢´Ê∑ãÊøïÂæóÂæà____„ÄÇ",
  "ÂõõÈù¢ÂÖ´Êñπ": "È¢±È¢®‰æÜËá®ÔºåÊµ∑Èù¢‰∏äÊµ™Ëä±Âæû____Êç≤‰æÜ„ÄÇ",
  "ÈÄ£Âøô": "ÁêÉÊªæÂà∞È¶¨Ë∑ØÊóÅÔºå‰ªñ____ÊääÂÆÉÊíøÂõû‰æÜ„ÄÇ",
  "Á®±ËÆö": "ËÄÅÂ∏´____Â∞èÊÄù‰ªäÂÄãÂ≠∏ÊúüÂêÑÂÄãÁßëÁõÆÂùáÊúâÈÄ≤Ê≠•„ÄÇ",
  "Ë°®Êèö": "ÁÇ∫‰∫Ü____‰Ω†ÂÄëÁöÑÂêà‰ΩúÁ≤æÁ•ûÔºåËÄÅÂ∏´ÁâπÂà•Ë≤º‰∏äÊòüÊòüË≤ºÁ¥ô„ÄÇ",
  "ÊªëÊ∫úÊ∫ú": "Âú∞ÊùøË¢´Èõ®Ê∞¥ÂºÑÂæó____ÔºåËµ∞Ë∑ØË¶ÅÁâπÂà•Â∞èÂøÉÂë¢!",
  "ÊÉ¶Ë®ò": "Â™ΩÂ™ΩÂá∫ÈñÄÂ∑•‰ΩúÔºåÊàë‰∏ÄÁõ¥____ÁùÄÂ•π„ÄÇ",
  "ÈÇÄË´ã": "Â≠∏Ê†°____ÂÆ∂Èï∑ÂèÉÂä†ÈÅãÂãïÊúÉ„ÄÇ",
  "Á•ùÁ¶è": "Âú®ÁîüÊó•ÊúÉ‰∏äÔºåÊàëÂÄë‰∏ÄËµ∑____Â£ΩÊòüË∫´È´îÂÅ•Â∫∑„ÄÇ",
  "‰ΩîÁî®": "ÈÄôÂºµÊ°åÂ≠êÂ∑≤Ë¢´ÂÖ∂‰ªñÂêåÂ≠∏____‰∫Ü„ÄÇ",
  "ÂÆâÊÖ∞": "Â¶πÂ¶πË∑åÂÄíÂì≠‰∫ÜÔºåÊàëËºïËºïÂú∞____Â•π„ÄÇ",
  "ÂøôÁ¢å": "‰ªäÂ§©Ê¥ªÂãïÂæàÂ§öÔºåÂ§ßÂÆ∂ÈÉΩÂæà____„ÄÇ",
  "ÁçéÂãµ": "Â¶ÇÊûú‰Ω†ËÄÉÂæóÂ•ΩÔºåÂ™ΩÂ™ΩÊúÉ____‰Ω†‰∏ÄÂÄãÂ§ßÂ§ßÁöÑÊìÅÊä±„ÄÇ",
  "ÈÖ£Áù°": "Â∞èÁãóÂú®ÈôΩÂÖâ‰∏ã____ÔºåÁù°ÂæóÂæàÁîú„ÄÇ",
  "Ë≤¨‰ªª": "ÁÖßÈ°ßÁè≠Á¥öÊ§çÁâ©ÊòØÊàëÂÄëÂÖ±ÂêåÁöÑ____„ÄÇ",
  "ÈÄêÊº∏": "Èõ®Âã¢____ËÆäÂ∞èÔºåÂ§©Ëâ≤‰πü‰∫ÆËµ∑‰æÜ„ÄÇ",
  "Ëø´‰∏çÂèäÂæÖ": "ÊîæÂ≠∏ÈêòËÅ≤‰∏ÄÈüøÔºåÂêåÂ≠∏ÂÄë____Âú∞Ë°ùÂêëÊìçÂ†¥„ÄÇ",
  "Áí∞Â¢É": "ÊàëÂÄëË¶ÅÊÑõË≠∑Â≠∏Ê†°ÁöÑ____Ôºå‰øùÊåÅÊï¥ÊΩî„ÄÇ",
  "ÊµÅÂà©": "‰ªñË™™ÊôÆÈÄöË©±ÈùûÂ∏∏____ÔºåÂ§ßÂÆ∂ÈÉΩËÅΩÂæóÂæàÊäïÂÖ•„ÄÇ",
  "ÊîπÂñÑ": "ÊØèÂ§©Èñ±ËÆÄÊõ∏ËÉΩ____‰Ω†ÁöÑË™ûÊñáËÉΩÂäõ„ÄÇ",
  "ÂõûÂë≥": "ÈÄôÁ¢óÊπØÂ§™Â•ΩÂñù‰∫ÜÔºåÁúü‰ª§‰∫∫____!",
  "ÈÅ©Êáâ": "Êñ∞Â≠∏ÊúüÈñãÂßãÔºåÊàëÂæàÂø´Â∞±____‰∫ÜÊñ∞ÁöÑ‰ΩúÊÅØ„ÄÇ",
  "Ê∫ñÁ¢∫": "ÂÅöÊï∏Â≠∏ÊôÇÔºåÁ≠îÊ°àË¶ÅÂØ´Âæó____ÁÑ°Ë™§„ÄÇ",
  "ÊõºÂ¶ô": "Âè∞‰∏äÁöÑËàûËπàÂãï‰ΩúÂçÅÂàÜ____Ôºå‰ª§‰∫∫ËÆöÊ≠é„ÄÇ",
  "ÁîòÁîú": "ÁÜüÈÄèÁöÑËúúÁìú____ÂèØÂè£„ÄÇ",
  "ÊÇÑÊÇÑ": "‰ªñ____Ëµ∞Âà∞Á™óÈÇäÔºå‰∏çÊÉ≥ÂêµÈÜíÂêåÂ≠∏„ÄÇ",
  "È¶ôÊ∞£ÂõõÊ∫¢": "È∫µÂåÖ‰∏ÄÂá∫ÁàêÔºåÂ∫óÂÖß‰æø____„ÄÇ",
  "ÈáÄ": "ÈÄôÁì∂ÊûúÊ±ÅÊòØËæ≤Â§´ÂÄëË¶™Êâã____ÈÄ†ÁöÑ„ÄÇ",
  "Âê±Âê±Âñ≥Âñ≥": "Â∞èÈ≥•Âú®Ê®π‰∏ä____Âú∞Âè´ÁùÄ„ÄÇ",
  "ÊêñÊõ≥": "È¢®ÂêπÈÅé‰æÜÔºåËä±ÊúµÂú®Ëä±ÂúíË£°ËºïËºï____„ÄÇ",
  "ËáâÈæê": "Â™ΩÂ™ΩËºïËºïÊí´Êë∏ÊàëÁöÑ____ÔºåÂè´ÊàëÊîæÂøÉ„ÄÇ",
  "ÁëüÁëüÁôºÊäñ": "Â§©Ê∞£Â§™ÂÜ∑ÔºåÂ∞èË≤ìÂú®ËßíËêΩË£°____„ÄÇ",
  "ÂüãÊÄ®": "ÂÅöÈåØ‰∫ã‰∏çËÉΩ____Âà•‰∫∫ÔºåË¶ÅÂèçÁúÅËá™Â∑±„ÄÇ",
  "ÂóìÂ≠ê": "Â§ßËÅ≤ÂñäÂè´Â§™‰πÖÔºå‰ªñÁöÑ____ÊúâÈªûÁóõ„ÄÇ",
  "ÊÇ∂ÁÜ±": "‰ªäÂ§©Â§©Ê∞£____ÔºåÂ§ßÂÆ∂ÈÉΩÊÉ≥ÂñùÂáçÈ£≤„ÄÇ",
  "Ê∏ÖÊ∂º": "‰∏ÄÂè£ËñÑËç∑Ê∞¥ËÆì‰∫∫ÊÑüÂà∞ÈùûÂ∏∏____„ÄÇ",
  "ÊúüÂæÖ": "ÊàëÂÄëÈÉΩÂæà____‰∏ãÂë®ÁöÑÊà∂Â§ñÂ≠∏Áøí„ÄÇ",
  "Âêå‰º¥": "Âú®ÊØîË≥Ω‰∏≠ÔºåÊàëË¶ÅÂíå____Âêà‰ΩúÂÆåÊàê‰ªªÂãô„ÄÇ",
  "ËÆöÁæé": "ËÄÅÂ∏´____‰ªñÁöÑÈÄ≤Ê≠•ÔºåÂ∏åÊúõ‰ªñÁπºÁ∫åÂä™Âäõ„ÄÇ"


  // Existing
  "Â†ÖÊØÖ": "Èù¢Â∞çÂõ∞Èõ£ÊôÇÔºåÊàëÂÄëË¶ÅÊúâ____ÁöÑÁ≤æÁ•ûÔºå‰∏çÂèØËºïË®ÄÊîæÊ£Ñ„ÄÇ",
  "Â∞äÈáç": "ÊàëÂÄëË¶Å____Âà•‰∫∫ÁöÑÊÑèË¶ãÔºåÂç≥‰Ωø‰∏çÂêåÊÑè‰πü‰∏çÊáâÊÉ°Ë®ÄÁõ∏Âêë„ÄÇ",
  "Â≠∏Ê†°": "____ÊòØÊàëÂÄëÂ≠∏ÁøíÁü•Ë≠òÂíåË™çË≠òÊúãÂèãÁöÑÂú∞Êñπ„ÄÇ",
  "Âø´Ê®Ç": "Âπ´Âä©Âà•‰∫∫ÊòØ‰∏Ä‰ª∂____ÁöÑ‰∫ã„ÄÇ"
};

// --- HELPER FUNCTIONS ---

const generateGame2Questions = (vocabList) => {
  const questions = [];
  vocabList.forEach((item, idx) => {
    // 1. Try to find a similar char
    const charToTest = item.word.split('').find(c => SIMILAR_CHAR_MAP[c]);
    
    if (charToTest) {
      const similars = SIMILAR_CHAR_MAP[charToTest];
      const distractors = similars.map(sim => item.word.replace(charToTest, sim));
      const uniqueDistractors = [...new Set(distractors)];
      const options = [item.word, ...uniqueDistractors].slice(0, 4).sort(() => 0.5 - Math.random());
      
      questions.push({
        id: `g2-${idx}`, stage: 'differentiation', type: 'diff',
        mainChar: item.word, question: `Ë´ãÈÅ∏ÊìáÊ≠£Á¢∫ÁöÑÂ≠óË©û (Select correct word):`,
        context: `Meaning: ${item.meaning}`, options: options, correctAnswer: item.word,
        explanationZh: `„Äå${charToTest}„ÄçÂÆπÊòìËàá„Äå${similars.join('„ÄÅ')}„ÄçÊ∑∑Ê∑Ü„ÄÇ`,
        explanationEn: `Be careful with the shape of '${charToTest}'. It looks similar to ${similars.join('/')}.`
      });
    } else {
      // 2. FALLBACK: Word Recognition (Select correct Chinese word for English Meaning)
      const otherWords = vocabList.filter(v => v.word !== item.word).map(v => v.word);
      const distractors = otherWords.sort(() => 0.5 - Math.random()).slice(0, 3);
      const options = [item.word, ...distractors].sort(() => 0.5 - Math.random());

      questions.push({
        id: `g2-${idx}`, stage: 'differentiation', type: 'recognition',
        mainChar: item.word, question: `Ë´ãÈÅ∏ÊìáÊ≠£Á¢∫ÁöÑ‰∏≠ÊñáË©ûÂΩô (Select the correct word):`,
        context: `Meaning: ${item.meaning}`, options: options, correctAnswer: item.word,
        explanationZh: `„Äå${item.word}„ÄçÁöÑÊÑèÊÄùÊòØ ${item.meaning}„ÄÇ`,
        explanationEn: `The Chinese word for "${item.meaning}" is "${item.word}".`
      });
    }
  });
  return questions;
};

const generateGame3Questions = (vocabList) => {
  const questions = [];
  vocabList.forEach((item, idx) => {
    // 1. Try to find relations
    const relation = RELATIONS_DB[item.word];
    if (relation) {
      const options = [relation.target, ...relation.distractors].sort(() => 0.5 - Math.random());
      questions.push({
        id: `g3-${idx}`, stage: 'relations', type: 'relation',
        mainChar: item.word, target: item.word, mode: relation.mode,
        question: `ÊâæÂá∫„Äå${item.word}„ÄçÁöÑ${relation.mode.split(' ')[0]}Ôºö`,
        options: options, correctAnswer: relation.target,
        explanationZh: `„Äå${item.word}„ÄçËàá„Äå${relation.target}„ÄçÊòØ${relation.mode.split(' ')[0]}Èóú‰øÇ„ÄÇ`,
        explanationEn: `'${item.word}' and '${relation.target}' are ${relation.type}s.`
      });
    } else {
      // 2. FALLBACK: Reverse Definition Match
      const otherWords = vocabList.filter(v => v.word !== item.word).map(v => v.word);
      const distractors = otherWords.sort(() => 0.5 - Math.random()).slice(0, 3);
      const options = [item.word, ...distractors].sort(() => 0.5 - Math.random());

      questions.push({
        id: `g3-${idx}`, stage: 'relations', type: 'reverse-def',
        mainChar: item.meaning, 
        target: item.word,
        mode: "Ë©ûÁæ©ÈÖçÂ∞ç (Match Word)",
        question: `Âì™ÂÄãË©ûÂΩôÁöÑÊÑèÊÄùÊòØ "${item.meaning}"Ôºü`,
        options: options, correctAnswer: item.word,
        explanationZh: `„Äå${item.word}„ÄçÂ∞çÊáâÁöÑËã±ÊñáËß£ÈáãÊòØ ${item.meaning}„ÄÇ`,
        explanationEn: `"${item.word}" matches the definition "${item.meaning}".`
      });
    }
  });
  return questions;
};

const generateGame4Questions = (vocabList) => {
  const questions = [];
  vocabList.forEach((item, idx) => {
    const sentence = SENTENCE_DB[item.word];
    if (sentence) {
      for (let i = 0; i < 3; i++) {
        const otherWords = vocabList.filter(v => v.word !== item.word).map(v => v.word);
        const dictWords = Object.keys(SENTENCE_DB).filter(k => k !== item.word);
        const pool = [...otherWords, ...dictWords];
        const distractors = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
        const options = [item.word, ...distractors].sort(() => 0.5 - Math.random());
        
        questions.push({
          id: `g4-${idx}-${i}`, 
          stage: 'fillInBlanks', 
          type: 'fill',
          mainChar: item.word, 
          sentence: sentence,
          question: `Ë´ãÈÅ∏ÊìáÊúÄÈÅ©ÂêàÁöÑË©ûË™ûÂ°´Á©∫ (${i+1}/3)Ôºö`, 
          options: options, 
          correctAnswer: item.word,
          explanationZh: `ÈÄôÂè•Ë©±ÁöÑÊÑèÊÄùÊòØÔºö${sentence.replace('____', item.word)}`,
          explanationEn: "Select the word that best fits the context of the sentence."
        });
      }
    }
  });
  return questions;
};

// --- COMPONENTS ---

const Card = ({ children, className = "" }) => (
  <div className={`bg-white rounded-xl shadow-lg p-6 ${className}`}>
    {children}
  </div>
);

const Button = ({ onClick, disabled, variant = "primary", children, className = "" }) => {
  const baseStyle = "px-4 py-3 rounded-lg font-bold transition-all transform active:scale-95 duration-200 flex items-center justify-center gap-2 text-sm md:text-base";
  const variants = {
    primary: "bg-indigo-600 text-white hover:bg-indigo-700 shadow-md",
    secondary: "bg-teal-500 text-white hover:bg-teal-600 shadow-md",
    outline: "border-2 border-indigo-200 text-indigo-600 hover:bg-indigo-50",
    correct: "bg-green-500 text-white shadow-md ring-4 ring-green-200",
    wrong: "bg-red-500 text-white shadow-md ring-4 ring-red-200",
    disabled: "bg-gray-300 text-gray-500 cursor-not-allowed opacity-60",
    icon: "p-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg"
  };
  return <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${disabled ? variants.disabled : variants[variant]} ${className}`}>{children}</button>;
};

const FeedbackModal = ({ isCorrect, explanationZh, explanationEn, onNext }) => (
  <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50 animate-in fade-in duration-300">
    <div className="bg-white rounded-2xl p-6 md:p-8 max-w-lg w-full shadow-2xl transform transition-all scale-100 max-h-[90vh] overflow-y-auto">
      <div className="flex flex-col items-center text-center">
        {isCorrect ? <CheckCircle className="w-16 h-16 text-green-500 mb-4" /> : <XCircle className="w-16 h-16 text-red-500 mb-4" />}
        <h3 className={`text-2xl font-bold mb-2 ${isCorrect ? 'text-green-600' : 'text-red-600'}`}>{isCorrect ? "Á≠îÂ∞ç‰∫ÜÔºÅ(Correct!)" : "ÂÜçÊé•ÂÜçÂé≤ÔºÅ(Try Again)"}</h3>
        <div className="bg-indigo-50 p-4 rounded-lg border border-indigo-100 my-4 text-left w-full space-y-4">
          <div>
            <p className="text-indigo-900 font-bold mb-1 flex items-center gap-2"><span className="text-lg">üá®üá≥</span> Ëß£Èáã (Chinese):</p>
            <p className="text-gray-800 leading-relaxed text-base pl-8">{explanationZh}</p>
          </div>
          <div className="border-t border-indigo-200 pt-3">
            <p className="text-indigo-900 font-bold mb-1 flex items-center gap-2"><span className="text-lg">üá∫üá∏</span> Explanation (English):</p>
            <p className="text-gray-800 leading-relaxed text-base pl-8">{explanationEn}</p>
          </div>
        </div>
        <Button onClick={onNext} variant={isCorrect ? "primary" : "secondary"} className="w-full">{isCorrect ? "‰∏ã‰∏ÄÈ°å (Next)" : "ÊòéÁôΩ (Got it)"}</Button>
      </div>
    </div>
  </div>
);

const StageTransition = ({ stage, onComplete }) => {
  useEffect(() => {
    const timer = setTimeout(onComplete, 2000);
    return () => clearTimeout(timer);
  }, [onComplete]);

  return (
    <div className="fixed inset-0 bg-indigo-600 flex flex-col items-center justify-center z-50 animate-in fade-in duration-500 text-white">
      <div className="bg-white/20 p-6 rounded-full mb-6 backdrop-blur-sm animate-bounce">
        {stage.icon}
      </div>
      <h2 className="text-4xl font-bold mb-2">‰∏ã‰∏ÄÈóú (Next Level)</h2>
      <h3 className="text-2xl font-light">{stage.title}</h3>
      <p className="mt-4 opacity-80">{stage.desc}</p>
    </div>
  );
};

export default function App() {
  const [gameState, setGameState] = useState('welcome');
  const [importText, setImportText] = useState("");
  const [importedVocabList, setImportedVocabList] = useState([]);
  
  // Game Selection State
  const [selectedGameModes, setSelectedGameModes] = useState({
    translation: true,
    differentiation: true,
    relations: true,
    fillInBlanks: true
  });
  
  // Game Session State
  const [currentStageQuestions, setCurrentStageQuestions] = useState([]);
  const [currentQuestionIdx, setCurrentQuestionIdx] = useState(0);
  const [score, setScore] = useState(0);
  const [showFeedback, setShowFeedback] = useState(false);
  const [lastCorrect, setLastCorrect] = useState(false);
  const [selectedOption, setSelectedOption] = useState(null);
  const [showTransition, setShowTransition] = useState(false);
  const [wrongAnswers, setWrongAnswers] = useState([]); // Track wrong answers

  const STAGES_INFO = {
    translation: { title: 'Á¨¨‰∏ÄÈóúÔºö‰∏≠Ëã±ÈÖçÂ∞ç', icon: <Globe className="w-12 h-12"/>, desc: 'Translation Match' },
    differentiation: { title: 'Á¨¨‰∫åÈóúÔºöÂ≠óÂΩ¢Ëæ®Êûê', icon: <BookOpen className="w-12 h-12"/>, desc: 'Similar Characters' },
    relations: { title: 'Á¨¨‰∏âÈóúÔºöËøëÁæ©ËàáÂèçÁæ©', icon: <RefreshCw className="w-12 h-12"/>, desc: 'Synonyms & Antonyms' },
    fillInBlanks: { title: 'Á¨¨ÂõõÈóúÔºöË™ûÂ¢ÉÂ°´ÂÖÖ', icon: <HelpCircle className="w-12 h-12"/>, desc: 'Fill in the Blanks' }
  };

  useEffect(() => {
    const savedList = localStorage.getItem('chineseGame_vocabList');
    if (savedList) {
      try { 
        setImportedVocabList(JSON.parse(savedList)); 
      } catch (e) { console.error(e); }
    } else {
      // Init with default specific list if local storage empty
      const initList = DEFAULT_USER_LIST.map(item => ({ ...item, source: "manual", isSelected: true }));
      setImportedVocabList(initList);
      saveToLocalStorage(initList);
    }
  }, []);

  const saveToLocalStorage = (list) => localStorage.setItem('chineseGame_vocabList', JSON.stringify(list));

  const resetToDefault = () => {
    if(confirm("Reset to the default vocabulary list? This will clear your changes.")) {
       const initList = DEFAULT_USER_LIST.map(item => ({ ...item, source: "manual", isSelected: true }));
       setImportedVocabList(initList);
       saveToLocalStorage(initList);
       setGameState('confirm');
    }
  }

  const handleStartImport = () => {
    const currentText = importedVocabList.map(item => {
      if (item.source === 'manual' && item.meaning) return `${item.word}, ${item.meaning}`;
      return item.word;
    }).join('\n');
    setImportText(currentText);
    setGameState('import');
  };

  const processImport = () => {
    const lines = importText.split('\n');
    const processed = [];
    lines.forEach(line => {
       const trimmed = line.trim();
       if (!trimmed) return;
       const splitMatch = trimmed.match(/^([^,Ôºå:Ôºö\t-]+)[,Ôºå:Ôºö\t-](.+)$/);
       let word = "", meaning = "", source = "unknown";
       if (splitMatch) {
         word = splitMatch[1].trim(); meaning = splitMatch[2].trim(); source = "manual";
       } else {
         word = trimmed;
         if (VOCAB_DICTIONARY[word]) { meaning = VOCAB_DICTIONARY[word]; source = "google"; }
       }
       if (!processed.find(p => p.word === word)) {
          const existing = importedVocabList.find(i => i.word === word);
          processed.push({ word, meaning, source, isSelected: existing ? existing.isSelected : true });
       }
    });
    setImportedVocabList(processed);
    saveToLocalStorage(processed);
    setGameState('confirm');
  };

  const updateImportedMeaning = (index, newMeaning) => {
    const newList = [...importedVocabList];
    newList[index].meaning = newMeaning; newList[index].source = 'manual';
    setImportedVocabList(newList); saveToLocalStorage(newList);
  };

  const toggleImportSelection = (index) => {
    const newList = [...importedVocabList];
    newList[index].isSelected = !newList[index].isSelected;
    setImportedVocabList(newList); saveToLocalStorage(newList);
  };

  const toggleAllSelection = () => {
    const allSelected = importedVocabList.every(i => i.isSelected);
    const newList = importedVocabList.map(i => ({ ...i, isSelected: !allSelected }));
    setImportedVocabList(newList); saveToLocalStorage(newList);
  };

  const toggleGameMode = (mode) => {
    setSelectedGameModes(prev => ({ ...prev, [mode]: !prev[mode] }));
  };

  const confirmImportedList = () => {
    const activeList = importedVocabList.filter(i => i.isSelected);
    if (activeList.length === 0) { alert("Please select at least one word."); return; }
    
    if (!Object.values(selectedGameModes).some(v => v)) {
      alert("Please select at least one game mode to play.");
      return;
    }
    
    let q1 = [], q2 = [], q3 = [], q4 = [];
    
    // Game 1: Translation
    if (selectedGameModes.translation) {
      activeList.forEach((item, index) => {
         const otherMeanings = activeList.filter(v => v.meaning !== item.meaning).map(v => v.meaning);
         const dictMeanings = Object.values(VOCAB_DICTIONARY).filter(m => m !== item.meaning);
         const pool = [...otherMeanings, ...dictMeanings];
         const distractors = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
         while(distractors.length < 3) distractors.push("Unknown");
         
         q1.push({
          id: `g1-${index}`, stage: 'translation', type: 'translation',
          mainChar: item.word, question: `Ë´ãÈÅ∏Êìá„Äå${item.word}„ÄçÁöÑËã±ÊñáÊÑèÊÄù (Select English meaning):`,
          options: [item.meaning, ...distractors].sort(() => 0.5 - Math.random()),
          correctAnswer: item.meaning, explanationZh: `„Äå${item.word}„ÄçÁöÑÊÑèÊÄùÊòØ ${item.meaning}„ÄÇ`,
          explanationEn: `The English translation for "${item.word}" is "${item.meaning}".`
         });
      });
    }

    if (selectedGameModes.differentiation) {
      q2 = generateGame2Questions(activeList);
    }
    if (selectedGameModes.relations) {
      q3 = generateGame3Questions(activeList);
    }
    if (selectedGameModes.fillInBlanks) {
      q4 = generateGame4Questions(activeList);
    }
    
    // Shuffle each stage independently
    q1.sort(() => 0.5 - Math.random());
    q2.sort(() => 0.5 - Math.random());
    q3.sort(() => 0.5 - Math.random());
    q4.sort(() => 0.5 - Math.random());

    const allQuestions = [...q1, ...q2, ...q3, ...q4];
    
    if (allQuestions.length === 0) {
      alert("No questions could be generated. Try selecting more words or different game modes.");
      return;
    }

    setCurrentStageQuestions(allQuestions);
    setScore(0);
    setCurrentQuestionIdx(0);
    setWrongAnswers([]); 
    setGameState('playing');
  };

  const handleAnswer = (answer) => {
    const currentQ = currentStageQuestions[currentQuestionIdx];
    setSelectedOption(answer);
    const isCorrect = answer === currentQ.correctAnswer;
    setLastCorrect(isCorrect);
    
    if (isCorrect) {
      setScore(s => s + 10);
    } else {
      // Record wrong answer
      setWrongAnswers(prev => [...prev, {
        question: currentQ.mainChar || currentQ.question, 
        type: STAGES_INFO[currentQ.stage].title,
        correct: currentQ.correctAnswer,
        userChoice: answer
      }]);
    }
    
    setTimeout(() => setShowFeedback(true), 400);
  };

  const handleNext = () => {
    setShowFeedback(false);
    setSelectedOption(null);
    
    if (currentQuestionIdx < currentStageQuestions.length - 1) {
      const currentStage = currentStageQuestions[currentQuestionIdx].stage;
      const nextStage = currentStageQuestions[currentQuestionIdx + 1].stage;
      if (currentStage !== nextStage) setShowTransition(true);
      setCurrentQuestionIdx(prev => prev + 1);
    } else {
      setGameState('summary');
    }
  };

  // --- RENDER MODES ---
  if (gameState === 'welcome') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 flex items-center justify-center p-4">
        <Card className="max-w-2xl w-full text-center py-12">
          <div className="bg-indigo-100 w-20 h-20 rounded-full flex items-center justify-center mx-auto mb-6">
            <BookOpen className="w-10 h-10 text-indigo-600" />
          </div>
          <h1 className="text-4xl font-extrabold text-gray-800 mb-4 tracking-tight">‰∏≠ÊñáË©ûÂΩôÂ§ßÊåëÊà∞</h1>
          <p className="text-xl text-gray-600 mb-8">Chinese Vocabulary Master</p>
          <div className="flex flex-col gap-3 max-w-xs mx-auto">
             <Button onClick={() => setGameState('confirm')} variant="primary" className="w-full text-lg shadow-xl">
               ÈñãÂßã (Start) <ArrowRight className="w-5 h-5" />
             </Button>
          </div>
        </Card>
      </div>
    );
  }

  if (gameState === 'import') {
    return (
      <div className="min-h-screen bg-gray-50 p-4 font-sans flex items-center justify-center">
        <Card className="max-w-2xl w-full">
           <header className="mb-6">
              <h1 className="text-2xl font-bold text-gray-800 flex items-center gap-2"><Upload className="w-6 h-6 text-indigo-600"/> Á∑®ËºØË©ûÂΩô (Edit Vocabulary)</h1>
              <div className="mt-3 bg-blue-50 p-3 rounded-lg text-sm text-blue-800 border border-blue-100">
                <strong>Format:</strong> <code>Word, Meaning</code> (One per line)
              </div>
           </header>
           <textarea className="w-full h-64 p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 font-mono mb-6"
             placeholder={`Â≠∏Ê†°, School\n...`} value={importText} onChange={(e) => setImportText(e.target.value)} />
           <div className="flex gap-4">
             <Button variant="outline" onClick={() => setGameState('confirm')} className="flex-1">Back</Button>
             <Button onClick={processImport} disabled={!importText.trim()} className="flex-1">Process & Save <ArrowRight className="w-4 h-4" /></Button>
           </div>
        </Card>
      </div>
    );
  }

  if (gameState === 'confirm') {
    const selectedCount = importedVocabList.filter(i => i.isSelected).length;
    return (
      <div className="min-h-screen bg-gray-50 p-4 font-sans flex items-center justify-center">
        <Card className="max-w-5xl w-full h-[90vh] flex flex-col">
           <header className="mb-2 flex flex-col md:flex-row justify-between items-start md:items-center border-b pb-4 gap-4">
              <div><h1 className="text-2xl font-bold text-gray-800">ÈÅäÊà≤Ë®≠ÂÆö (Game Setup)</h1><p className="text-sm text-gray-500">Confirm vocabulary and choose games.</p></div>
              <div className="flex items-center gap-2">
                 <Button variant="outline" onClick={resetToDefault} className="text-xs h-8 px-2"><RotateCcw className="w-3 h-3 mr-1"/> Reset Default</Button>
                 <span className="text-xl font-bold text-indigo-600">{selectedCount}</span>
                 <span className="text-sm text-gray-500">Words</span>
              </div>
           </header>
           
           <div className="grid md:grid-cols-3 gap-6 flex-1 min-h-0">
             {/* LEFT: Vocab List */}
             <div className="md:col-span-2 flex flex-col min-h-0 border rounded-lg bg-gray-50 shadow-inner">
               <div className="p-2 bg-gray-100 border-b flex justify-between items-center">
                 <span className="font-bold text-gray-600 text-sm pl-2">Vocabulary List</span>
                 <div className="flex gap-2">
                   <Button variant="outline" onClick={handleStartImport} className="text-xs h-7 px-2 bg-white"><Edit3 className="w-3 h-3 mr-1"/>Edit</Button>
                   <Button variant="outline" onClick={toggleAllSelection} className="text-xs h-7 px-2 bg-white">Toggle All</Button>
                 </div>
               </div>
               <div className="flex-1 overflow-y-auto p-0">
                 <table className="w-full text-left border-collapse text-sm">
                    <thead className="bg-white sticky top-0 shadow-sm z-10">
                      <tr>
                        <th className="p-2 w-10 text-center"><input type="checkbox" checked={importedVocabList.every(i => i.isSelected)} onChange={toggleAllSelection} className="w-4 h-4"/></th>
                        <th className="p-2">Word</th>
                        <th className="p-2">Meaning</th>
                      </tr>
                    </thead>
                    <tbody className="bg-white">
                      {importedVocabList.map((item, idx) => (
                        <tr key={idx} className={`border-b ${item.isSelected ? 'bg-white' : 'bg-gray-100 opacity-60'}`}>
                          <td className="p-2 text-center"><input type="checkbox" checked={item.isSelected} onChange={() => toggleImportSelection(idx)} className="w-4 h-4 text-indigo-600 rounded cursor-pointer" /></td>
                          <td className="p-2 font-bold text-gray-800">{item.word}</td>
                          <td className="p-2 text-gray-600">
                             <input type="text" value={item.meaning} onChange={(e) => updateImportedMeaning(idx, e.target.value)} className="w-full p-1 border rounded text-xs" />
                          </td>
                        </tr>
                      ))}
                    </tbody>
                 </table>
               </div>
             </div>

             {/* RIGHT: Game Mode Selection */}
             <div className="flex flex-col gap-4 overflow-y-auto pr-1">
               <div className="font-bold text-gray-700 flex items-center gap-2"><LayoutGrid className="w-5 h-5"/> Select Games to Play</div>
               
               {Object.keys(STAGES_INFO).map(key => (
                 <div key={key} 
                      onClick={() => toggleGameMode(key)}
                      className={`p-4 rounded-xl border-2 cursor-pointer transition-all ${selectedGameModes[key] ? 'border-indigo-500 bg-indigo-50 shadow-md' : 'border-gray-200 bg-white hover:border-indigo-200'}`}>
                   <div className="flex items-center gap-3 mb-2">
                     <div className={`p-2 rounded-full ${selectedGameModes[key] ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-400'}`}>
                       {selectedGameModes[key] ? <CheckCircle className="w-5 h-5"/> : <XCircle className="w-5 h-5"/>}
                     </div>
                     <span className="font-bold text-gray-800">{STAGES_INFO[key].title.split('Ôºö')[1]}</span>
                   </div>
                   <p className="text-xs text-gray-500 ml-12">{STAGES_INFO[key].desc}</p>
                 </div>
               ))}

               <div className="mt-auto pt-4">
                 <Button onClick={confirmImportedList} className="w-full h-14 text-lg bg-green-600 hover:bg-green-700 shadow-xl">
                   PLAY NOW <Star className="w-5 h-5 ml-1" />
                 </Button>
                 <p className="text-xs text-center text-gray-400 mt-2">Generates questions based on selection.</p>
               </div>
             </div>
           </div>
        </Card>
      </div>
    );
  }

  if (gameState === 'summary') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 flex items-center justify-center p-4">
        <Card className="max-w-2xl w-full text-center py-8 flex flex-col max-h-[90vh]">
          <div className="flex-shrink-0">
            <Award className="w-20 h-20 text-yellow-500 mx-auto mb-4 animate-bounce" />
            <h2 className="text-3xl font-bold text-gray-800 mb-2">ÊÅ≠ÂñúÂÆåÊàêÔºÅ</h2>
            <div className="text-5xl font-black text-indigo-600 mb-2">{score}</div>
          </div>

          {wrongAnswers.length > 0 && (
            <div className="flex-1 overflow-hidden flex flex-col mt-4 border-t pt-4">
              <h3 className="text-lg font-bold text-red-600 mb-2 flex items-center justify-center gap-2">
                <XCircle className="w-5 h-5"/> Incorrect Answers Review
              </h3>
              <div className="flex-1 overflow-y-auto bg-red-50 rounded-lg p-2 text-left">
                <table className="w-full text-sm">
                  <thead className="border-b border-red-200 text-red-800">
                    <tr>
                      <th className="p-2">Question/Word</th>
                      <th className="p-2">Your Answer</th>
                      <th className="p-2">Correct Answer</th>
                    </tr>
                  </thead>
                  <tbody>
                    {wrongAnswers.map((item, idx) => (
                      <tr key={idx} className="border-b border-red-100 last:border-0">
                        <td className="p-2 font-bold text-gray-700">{item.question} <span className="text-xs text-gray-400 block">{item.type}</span></td>
                        <td className="p-2 text-red-600 line-through">{item.userChoice}</td>
                        <td className="p-2 text-green-600 font-bold">{item.correct}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          <div className="flex gap-4 justify-center mt-6 flex-shrink-0">
            <Button onClick={() => setGameState('confirm')} variant="outline">Play Again</Button>
            <Button onClick={() => setGameState('welcome')} variant="secondary">Home</Button>
          </div>
        </Card>
      </div>
    );
  }

  if (currentStageQuestions.length === 0) return <div>Loading...</div>;

  const currentQ = currentStageQuestions[currentQuestionIdx];
  const currentStageInfo = STAGES_INFO[currentQ.stage];

  return (
    <div className="min-h-screen bg-gray-50 p-4 md:p-8 font-sans">
      {showTransition && <StageTransition stage={currentStageInfo} onComplete={() => setShowTransition(false)} />}
      
      <div className="max-w-4xl mx-auto">
        {/* NAV BAR */}
        <div className="flex justify-between items-center mb-4">
           <Button variant="icon" onClick={() => setGameState('welcome')} className="bg-white hover:bg-gray-100 text-gray-600">
             <Home className="w-5 h-5" />
           </Button>
           <Button variant="icon" onClick={() => setGameState('summary')} className="bg-white hover:bg-red-50 text-red-500 border border-red-100">
             <LogOut className="w-5 h-5 mr-1" /> End Game
           </Button>
        </div>

        <header className="flex justify-between items-center mb-8 bg-white p-4 rounded-xl shadow-sm">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-indigo-100 rounded-lg text-indigo-600">{currentStageInfo.icon}</div>
            <div><h2 className="font-bold text-gray-800">{currentStageInfo.title}</h2><p className="text-xs text-gray-500 hidden md:block">{currentStageInfo.desc}</p></div>
          </div>
          <div className="flex items-center gap-2 bg-yellow-50 px-4 py-2 rounded-full border border-yellow-100"><Star className="w-5 h-5 text-yellow-500 fill-current" /><span className="font-bold text-yellow-700">{score}</span></div>
        </header>
        
        <div className="w-full mb-6">
          <div className="flex justify-between text-sm font-medium text-gray-600 mb-2"><span>Game Progress</span><span>{currentQuestionIdx + 1} / {currentStageQuestions.length}</span></div>
          <div className="h-3 bg-gray-200 rounded-full overflow-hidden"><div className="h-full bg-indigo-500 transition-all duration-500 ease-out" style={{ width: `${((currentQuestionIdx + 1) / currentStageQuestions.length) * 100}%` }} /></div>
        </div>

        <div className="grid md:grid-cols-2 gap-6">
          <Card className="flex flex-col justify-center min-h-[300px]">
            <span className="inline-block px-3 py-1 bg-indigo-50 text-indigo-600 rounded-full text-xs font-bold mb-4 w-fit">Question {currentQuestionIdx + 1}</span>
            <h3 className="text-xl text-gray-800 mb-6 font-medium leading-relaxed">{currentQ.question}</h3>
            <div className="bg-indigo-50 p-6 rounded-xl border-l-4 border-indigo-500 mb-4 text-center">
              {currentQ.type === 'translation' && <p className="text-6xl font-bold text-gray-800">{currentQ.mainChar}</p>}
              {currentQ.type === 'diff' && <p className="text-2xl font-serif text-gray-900">{currentQ.context}</p>}
              {currentQ.type === 'recognition' && <p className="text-2xl font-serif text-gray-900">{currentQ.context}</p>}
              {currentQ.type === 'reverse-def' && <p className="text-xl font-bold text-gray-800">{currentQ.mainChar}</p>}
              {currentQ.type === 'relation' && (<div><p className="text-5xl font-bold text-gray-800 mb-2">{currentQ.mainChar}</p><p className="text-sm text-gray-500">{currentQ.mode}</p></div>)}
              {currentQ.type === 'fill' && <p className="text-2xl font-serif text-gray-900 leading-loose text-left">{currentQ.sentence.replace(currentQ.mainChar, '____')}</p>}
            </div>
          </Card>
          <div className="grid gap-3">
            {currentQ.options.map((opt, idx) => {
              let variant = "outline";
              if (selectedOption === opt) variant = lastCorrect ? "correct" : "wrong";
              return (
                <Button key={idx} onClick={() => handleAnswer(opt)} variant={variant} disabled={selectedOption !== null} className="h-full text-lg justify-between">
                  <span className="flex items-center gap-3"><span className="w-8 h-8 rounded-full bg-indigo-50 text-indigo-600 flex items-center justify-center text-sm font-bold">{String.fromCharCode(65 + idx)}</span><span className="font-bold text-2xl">{opt}</span></span>
                </Button>
              );
            })}
          </div>
        </div>
      </div>
      {showFeedback && <FeedbackModal isCorrect={lastCorrect} explanationZh={currentQ.explanationZh} explanationEn={currentQ.explanationEn} onNext={handleNext} />}
    </div>
  );
}
